/*
* generated by Xtext
*/
package de.nittka.tooling.jtag.ui.quickfix

import com.drew.imaging.ImageMetadataReader
import com.drew.metadata.Metadata
import com.drew.metadata.exif.ExifSubIFDDirectory
import de.nittka.tooling.jtag.jtag.Folder
import de.nittka.tooling.jtag.jtag.JtagFactory
import de.nittka.tooling.jtag.ui.validation.JtagUIValidator
import java.text.SimpleDateFormat
import java.util.TimeZone
import org.eclipse.core.resources.IFile
import org.eclipse.core.runtime.Path
import org.eclipse.xtext.ui.editor.quickfix.DefaultQuickfixProvider
import org.eclipse.xtext.ui.editor.quickfix.Fix
import org.eclipse.xtext.ui.editor.quickfix.IssueResolutionAcceptor
import org.eclipse.xtext.validation.Issue
import java.util.List
import de.nittka.tooling.jtag.jtag.File
import java.text.Collator
import java.util.Locale
import org.eclipse.core.resources.IContainer
import de.nittka.tooling.jtag.services.JtagGrammarAccess
import javax.inject.Inject
import org.eclipse.xtext.GrammarUtil
import java.util.Set

//import org.eclipse.xtext.ui.editor.quickfix.Fix
//import org.eclipse.xtext.ui.editor.quickfix.IssueResolutionAcceptor
//import org.eclipse.xtext.validation.Issue

/**
 * Custom quickfixes.
 *
 * see http://www.eclipse.org/Xtext/documentation.html#quickfixes
 */
class JtagQuickfixProvider extends DefaultQuickfixProvider {

	@Inject
	JtagGrammarAccess grammar;

	@Fix(JtagUIValidator::MISSING_JTAG_FILE)
	def addMissingXarchive(Issue issue, IssueResolutionAcceptor acceptor) {
		val fileNames=issue.data.get(0).split(";;").toList
		acceptor.accept(issue, 'Jtag entries for '+fileNames.join(",\n"), 'creates new entries', null) [
			obj, context |
			val container=context.xtextDocument.getAdapter(IFile).parent
			val filesToAdd=getFiles(container, fileNames)
			val folder=obj as Folder
			folder.files.addAll(filesToAdd)
		]
	}

	def List<File> getFiles(IContainer container, List<String> fileNames){
		val List<File>entriesToAdd=newArrayList
		val sorter=Collator.getInstance(Locale.GERMANY)
		fileNames.sortInplace([a,b|sorter.compare(a,b)])
		.filter[name|!name.isIgnoreFileName]
		.forEach[fileName|
			val target=container.getFile(new Path(fileName))
			val factory =JtagFactory.eINSTANCE
			val newEntry=factory.createFile
			newEntry.setFileName(factory.createFileName)
			newEntry.fileName.setFileName(maybeEscape(target.fullPath.lastSegment))
			val date=getDate(target)
			newEntry.setDate(date)
			newEntry.tags.add("quickfix")
			if(date===null){
				newEntry.tags.add("noDate")
			}
			entriesToAdd.add(newEntry)
		]
		return entriesToAdd
	}

	def private boolean isIgnoreFileName(String fileName){
		if(fileName==".project" || fileName.endsWith(".jtag")){
			return true
		}
		return false;
	}

	def private String maybeEscape(String fileName){
		//rough approximation of the FileNameWithExtension rule
		//if the name matches - no escaping necessary
		val Set<String> keywords=GrammarUtil.getAllKeywords(grammar.grammar);
		val char dot='.'
		if(keywords.exists[fileName.startsWith(it)]){
			//escaping necessary
		}else if(fileName.matches("[a-zA-Z0-9._-]*")){
			val int firstDotIndex=fileName.indexOf(dot)
			if(firstDotIndex<=0 || fileName.substring(firstDotIndex+1).indexOf(dot) <=0){
				return fileName;
			}
		}
		return '''"«fileName»"'''
	}

	def private static String getDate(IFile f){
		try{
			val Metadata metadata = ImageMetadataReader.readMetadata(f.contents);
			val dir= metadata.directories.filter(ExifSubIFDDirectory).head
			if(dir!==null){
				val date=(dir as ExifSubIFDDirectory).getDateOriginal(TimeZone.^default)
				val SimpleDateFormat format=new SimpleDateFormat("yyyy-MM-dd")
				return format.format(date)
			}
		}catch(Exception e){
			//ignore
		}
		return null
	}
}